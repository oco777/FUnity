#if UNITY_EDITOR
using System.IO;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor;
using FUnity.Runtime.Core;

namespace FUnity.EditorTools
{
    // なぜ: FUnity用Actor UIテンプレを即時生成し著者作業を簡略化したい。何を: UXML/USSとActorDataリンク。
    // どうする: エディタウィンドウからテンプレ設定を受け取りファイル生成・リンク処理を一括実行する。
    public class GenerateActorUITemplateWindow : EditorWindow
    {
        // なぜ: Actorテンプレートを識別し再利用したい。何を: 生成するUXML/USSのベース名。どうする: 入力値でファイル名を決定。
        private string m_TemplateName = "MyActor";
        // なぜ: 生成物をプロジェクトに配備する必要がある。何を: UXML/USSの出力フォルダ。どうする: 指定パスに書き出す。
        private string m_Folder = "Assets/FUnity/Generated/UI";
        // なぜ: ランタイムで画像差し替え箇所を特定したい。何を: VisualElement.Q()で探すportrait用スロット名。
        // どうする: UXML内のname属性として埋め込み、差し込み先を決定する。
        private string m_PortraitSlot = "portrait";
        // なぜ: UIサイズをテンプレで統制したい。何を: 生成UXMLに反映する幅。どうする: USSにwidthをpx指定。
        private int m_Width = 128;
        // なぜ: UI高さも合わせたい。何を: 生成UXMLの高さ。どうする: USSのheightにpx指定。
        private int m_Height = 128;
        // なぜ: ブランドカラーをテンプレで共有したい。何を: 背景に使うPrimaryColor。どうする: USSにrgbaで埋め込む。
        private Color m_PrimaryColor = new Color(0.15f, 0.6f, 1f, 1f);
        // なぜ: 生成直後にアクター定義へ適用したい。何を: 選択中FUnityActorDataとのリンク要否。どうする: trueならSelection経由で適用。
        private bool m_LinkToSelectedActor = true;

        [MenuItem("FUnity/Authoring/Generate Actor UI Template...")]
        public static void Open()
        {
            // なぜ: 著者に最小テンプレ生成を提供したい。何を: FUnity向けUXML/USSを作る専用ウィンドウ。どうする: EditorWindowを開く。
            var w = GetWindow<GenerateActorUITemplateWindow>("Generate Actor UI");
            w.minSize = new Vector2(420, 320);
            w.Show();
        }

        private void OnGUI()
        {
            // なぜ: テンプレ構成要素を一括設定したい。何を: 名前/出力先/portraitスロット/サイズ/色/リンク有無の入力群。
            // どうする: EditorGUILayoutでフォームを描画し、生成ボタンでUXML/USS出力とActorDataリンクを実行する。
            EditorGUILayout.LabelField("UXML/USS Generator (FUnityProject)", EditorStyles.boldLabel);
            EditorGUILayout.Space();

            m_TemplateName = EditorGUILayout.TextField("Template Name", m_TemplateName);
            m_Folder = EditorGUILayout.TextField("Output Folder", m_Folder);
            m_PortraitSlot = EditorGUILayout.TextField("Portrait Slot Name", m_PortraitSlot);
            m_Width = EditorGUILayout.IntField("Width (px)", m_Width);
            m_Height = EditorGUILayout.IntField("Height (px)", m_Height);
            m_PrimaryColor = EditorGUILayout.ColorField("Primary Color", m_PrimaryColor);
            m_LinkToSelectedActor = EditorGUILayout.Toggle("Link to selected FUnityActorData", m_LinkToSelectedActor);

            EditorGUILayout.Space();
            if (GUILayout.Button("Create UXML/USS and Link"))
            {
                CreateFilesAndLink();
            }
        }

        /// <summary>
        /// <list type="bullet">
        /// <item><description>出力フォルダを用意する。</description></item>
        /// <item><description>UXML/USSを生成し保存する。</description></item>
        /// <item><description>必要であれば選択中FUnityActorDataへリンクする。</description></item>
        /// <item><description>アセット保存とRefreshを行う。</description></item>
        /// </list>
        /// </summary>
        private void CreateFilesAndLink()
        {
            if (string.IsNullOrEmpty(m_TemplateName))
            {
                EditorUtility.DisplayDialog("Error", "Template Name is required.", "OK");
                return;
            }

            // なぜ: 生成ファイルの格納場所を確保したい。何を: 指定フォルダ。どうする: Directory.CreateDirectoryで作成。
            Directory.CreateDirectory(m_Folder);
            var uxmlPath = $"{m_Folder}/{m_TemplateName}.uxml";
            var ussPath = $"{m_Folder}/{m_TemplateName}.uss";

            // --- Generate USS text ---
            // なぜ: 見た目をテンプレ設定で統一したい。何を: width/height/PrimaryColorなどのスタイル。どうする: USS文字列へ値を埋め込む。
            var uss =
                $@"/* {m_TemplateName}.uss — generated by FUnity */
.actor-root {{
    width: {m_Width}px;
    height: {m_Height}px;
    border-radius: 12px;
    background-color: rgba({(int)(m_PrimaryColor.r * 255)},{(int)(m_PrimaryColor.g * 255)},{(int)(m_PrimaryColor.b * 255)},{m_PrimaryColor.a});
    justify-content: center;
    align-items: center;
}}
.actor-portrait {{
    width: 100%;
    height: 100%;
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    -unity-background-scale-mode: scale-to-fit;
}}
";

            // --- Generate UXML text ---
            // なぜ: スロット付きレイアウトを提供したい。何を: rootとportrait VisualElement。どうする: UXML文字列でname/classを定義。
            var uxml =
                $@"<?xml version=""1.0"" encoding=""utf-8""?>
<ui:UXML xmlns:ui=""UnityEngine.UIElements"" xmlns:uie=""UnityEditor.UIElements"" editor-extension-mode=""False"">
    <!-- {m_TemplateName}.uxml — generated by FUnity -->
    <ui:VisualElement name=""root"" class=""actor-root"">
        <ui:VisualElement name=""{m_PortraitSlot}"" class=""actor-portrait"" />
    </ui:VisualElement>
</ui:UXML>
";

            // なぜ: テンプレ構造とスロットを定義したい。何を: VisualElement階層とportrait名。どうする: name/classをUXMLへ書き込む。
            File.WriteAllText(ussPath, uss);
            File.WriteAllText(uxmlPath, uxml);
            AssetDatabase.ImportAsset(ussPath);
            AssetDatabase.ImportAsset(uxmlPath);

            // Add USS to UXML (UI Builderでの読込に任せる or ランタイムで適用)
            // ここでは ActorData.ElementStyle にもセットするので、ランタイムは ve.styleSheets.Add(ElementStyle) で適用可能。

            // --- Link to FUnityActorData ---
            // なぜ: 生成したテンプレートを即活用できる状態にしたい。何を: 既存または新規FUnityActorData。
            // どうする: 選択中を優先し、無ければ新規アセットを作成する。
            FUnityActorData targetActor = null;
            if (m_LinkToSelectedActor && Selection.activeObject is FUnityActorData sel)
            {
                targetActor = sel;
            }
            else
            {
                // Create new one under same folder
                targetActor = ScriptableObject.CreateInstance<FUnityActorData>();
                AssetDatabase.CreateAsset(targetActor, $"{m_Folder}/FUnityActorData_{m_TemplateName}.asset");
            }

            // なぜ: 生成直後のテンプレートを参照に使いたい。何を: UXMLとUSSアセット。どうする: AssetDatabase.LoadAssetAtPathで取得。
            var uxmlAsset = AssetDatabase.LoadAssetAtPath<VisualTreeAsset>(uxmlPath);
            var ussAsset = AssetDatabase.LoadAssetAtPath<StyleSheet>(ussPath);

            if (targetActor == null)
            {
                Debug.LogError("[FUnity] Failed to resolve or create FUnityActorData target.");
                return;
            }

            // なぜ: SerializedObject経由で安全に書き換えたい。何を: ActorDataのUXML/USS参照。どうする: SerializedObjectを構築。
            var serializedActor = new SerializedObject(targetActor);
            var changed = false;

            // なぜ: UXML参照を最新に揃えたい。何を: m_ElementUxml。どうする: objectReferenceValueを生成資産に差し替える。
            var uxmlProperty = serializedActor.FindProperty("m_ElementUxml");
            if (uxmlProperty != null && uxmlProperty.objectReferenceValue != uxmlAsset)
            {
                uxmlProperty.objectReferenceValue = uxmlAsset;
                changed = true;
            }

            // なぜ: USS参照も同期したい。何を: m_ElementStyle。どうする: 新規StyleSheetを割り当てる。
            var ussProperty = serializedActor.FindProperty("m_ElementStyle");
            if (ussProperty != null && ussProperty.objectReferenceValue != ussAsset)
            {
                ussProperty.objectReferenceValue = ussAsset;
                changed = true;
            }

            if (changed)
            {
                // なぜ: 変更をアセットへ反映したい。何を: SerializedObjectの変更。どうする: ApplyとSetDirtyで保存状態を更新。
                serializedActor.ApplyModifiedPropertiesWithoutUndo();
                EditorUtility.SetDirty(targetActor);
            }

            // なぜ: AssetDatabaseに生成物を認識させたい。何を: UXML/USSとActorData。どうする: SaveAssetsとRefresh後にSelectionで通知。
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
            Selection.activeObject = targetActor;

            EditorUtility.DisplayDialog("Success", $"Created:\n{uxmlPath}\n{ussPath}\n\nLinked to: {targetActor.name}", "OK");
            Debug.Log($"[FUnity] Generated {uxmlPath} and {ussPath}, linked to {targetActor.name}.");
        }
    }
}
#endif
